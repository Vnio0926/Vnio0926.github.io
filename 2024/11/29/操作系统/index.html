<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vnio0926.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="只是简单的一个学习笔记...">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://vnio0926.github.io/2024/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Zhan的个人博客">
<meta property="og:description" content="只是简单的一个学习笔记...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\Typora\pics\Linux%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.jpg">
<meta property="article:published_time" content="2024-11-29T11:06:02.000Z">
<meta property="article:modified_time" content="2024-11-30T09:42:29.270Z">
<meta property="article:author" content="Zhan">
<meta property="article:tag" content="学习总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\Typora\pics\Linux%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.jpg">

<link rel="canonical" href="https://vnio0926.github.io/2024/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | Zhan的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zhan的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>guestbook</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Vnio0926" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://vnio0926.github.io/2024/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/Vnio0926/hexo-pic/master/img/fd0ae4423b520e2f15f345f0a369e08.jpg?token=BDPWDDEMRKIEUWVPL6ZR23LHJHGYA">
      <meta itemprop="name" content="Zhan">
      <meta itemprop="description" content="莫欺少年穷 莫欺中年穷 莫欺老年穷 死者为大">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-29 19:06:02" itemprop="dateCreated datePublished" datetime="2024-11-29T19:06:02+08:00">2024-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-30 17:42:29" itemprop="dateModified" datetime="2024-11-30T17:42:29+08:00">2024-11-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">技术学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">只是简单的一个学习笔记...</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a><strong>操作系统结构</strong></h3><p>   内核：连接硬件设备与应用软件的桥梁</p>
<p>   四个基本能力： 管理进程&#x2F;线程，管理内存，管理硬件设备，提供系统调用</p>
<p>   Linux内核理念： Muti Task，SMP， ELF， Monolithic Kernel（多任务，对称多处理，可执行文件链接格式，宏内核）</p>
<p>   鸿蒙用的是微内核，会带来更多的性能损耗，但是可移植性高</p>
<p>   Windows使用的是混合型内核</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><p>   操作系统提供一种机制：将不同进程的虚拟地址和不同内存的物理地址映射</p>
<p>   通过<strong>内存管理单元（MMU）</strong>来管理虚拟地址和物理地址之间的关系，主要是用内存分段和内存分页方法</p>
<p>   3.1 <strong>内存分段</strong></p>
<p>   通过 段选择子+段内偏移量 来进行定位</p>
<p>   映射方法： 先找段号（索引），找到对应的段基地址，再加上偏移量，得到物理内存地址</p>
<p>   缺点： <strong>内存碎片以及内存交换效率低</strong></p>
<p>   解决方法：<strong>内存交换</strong>（先写回硬盘，内存从硬盘中重新读取），会出现新的问题：交换占用内存大的应用程序会卡顿。因此出现更好的解决方法：内存分页</p>
<p>   3.2 <strong>内存分页</strong></p>
<p>   分页指的是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。（Linux系统下，每一页大小为4KB）</p>
<p>   这个方式的虚拟地址和物理地址通过 <strong>页表</strong> 来映射</p>
<p>   内存碎片问题：通过内存分页进行映射，内存释放时是以<strong>页</strong>为单位进行内存释放</p>
<p>   映射方法： 从虚拟地址中找到虚拟页号和页内偏移量，通过虚拟页号在页表中找到对应的物理页号，物理页号与页内偏移量相加，得到其物理内存地址</p>
<p>   缺点：多进程环境下需要的内存占用很大（因为每一个进程都有自己的虚拟地址空间，也就是说都有自己的页表）</p>
<p>   解决方法：引入多级页表</p>
<p>   3.3 <strong>段页式内存管理</strong></p>
<p>   内存分段+内存分页：将程序先划分为多个有逻辑意义的段，接着把每个段划分为多个页</p>
<p>   此时映射方法：段号+段内页号+页内偏移量</p>
<p>   优点：提高内存利用率        缺点：增加硬件成本和系统开销</p>
<p>   Linux系统内存主要采用页式内存管理，同时页涉及到了段机制</p>
<p>   <strong>总结</strong>：操作系统为每一个进程独立分配一套虚拟地址空间。虚拟地址与物理地址的映射通过分段或分页手段。 内存分段根据程序的逻辑角度进行，有栈段，堆段，数据段，代码段，文件映射段等。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><strong>进程与线程</strong></h3><p>   通过运行编译后的二进制可执行文件，它会被装载到内存，CPU对其中的指令进行运行。这个运行中的程序即为<strong>进程</strong></p>
<p>   进程的五种基本状态： 运行状态，就绪状态，阻塞状态，创建状态，结束状态</p>
<p>   以及挂起状态：描述进程没有占用实际的物理内存空间的情况。（阻塞挂起和就绪挂起）</p>
<p>   4.1 <strong>进程的控制结构</strong></p>
<p>   <strong>进程控制块（PCB）</strong>：进程存在的唯一标识，包含了<strong>进程描述信息</strong>，<strong>进程控制和管理信息</strong>，<strong>资源分配清单</strong>，<strong>CPU相关信息</strong></p>
<p>   <strong>进程描述信息</strong>：包含 进程标识符和用户标识符</p>
<p>   <strong>进程控制和管理信息</strong>：包含进程当前状态和进程优先级</p>
<p>   <strong>资源分配清单</strong>：内存地址空间，虚拟地址空间信息，所打开文件列表和所使用的I&#x2F;O设备信息</p>
<p>   <strong>CPU相关信息</strong>：CPU中各寄存器的值，切换进程时CPU状态信息会被保存在相应的PCB中，以便重新运行时在断点处继续执行</p>
<p>   4.2 <strong>进程的控制</strong></p>
<p>   <strong>创建进程</strong>：允许一个进程创建按另一个进程，且允许子进程继承父进程所拥有的资源。子进程被终止，从父进程继承的资源应归还给父进程。终止父进程时同时也会终止其所有子进程</p>
<ol>
<li><p>为新进程分配唯一的进程标识号，申请空白的PCB（由于PCB是有限的，所以可能会创建失败）</p>
</li>
<li><p>给进程分配资源，若资源不足，进程进入等待状态</p>
</li>
<li><p>初始化PCB</p>
</li>
<li><p>若进程的调度队列能接纳新进程，那就将进程插入到就绪队列，等待被调度运行</p>
</li>
</ol>
<p><strong>终止进程</strong>：有三种终止方式：正常结束，异常结束，外界干预</p>
<ol>
<li>查找需要终止的进程的PCB</li>
<li>进程处于执行状态：立即终止该进程的执行，将CPU资源分配给其他进程</li>
<li>如果有其他子进程，应将其所有子进程终止；</li>
<li>进程所拥有的全部资源归还给父进程或操作系统</li>
<li>将PCB所在的队列删除</li>
</ol>
<p><strong>阻塞进程</strong>：进程可以调用阻塞语句把自己阻塞等待。一旦被阻塞等待，只能由另一个进程唤醒</p>
<ol>
<li>找到将要被阻塞进程标识号对应的PCB</li>
<li>若进程为运行状态，则保护其现场，将其状态转变为阻塞状态，停止运行</li>
<li>将该PCB插入到阻塞队列</li>
</ol>
<p><strong>唤醒进程</strong>：当阻塞进程所期待的事件出现是，由发现者进程用唤醒语句叫醒它</p>
<ol>
<li>在该事件的阻塞队列中找到相应进程的PCB</li>
<li>将其从阻塞队列中移出，状态变更为就绪状态</li>
<li>将该PCB插入到就绪队列，等待调度程序调度</li>
</ol>
<p>注：若某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句</p>
<p><strong>进程的上下文切换</strong>是指一个进程切换到另一个进程运行</p>
<p>4.3 <strong>线程</strong></p>
<p>线程满足以下特性： 实体之间可以<strong>并发运行</strong>，实体之间<strong>共享相同的地址空间</strong>（实体指的就是线程）</p>
<p>线程优点：</p>
<ul>
<li><p>一个进程可以同时存在多个线程</p>
</li>
<li><p>各个线程之间可以并发执行</p>
</li>
<li><p>各个线程之间可以共享地址空间和文件资源</p>
</li>
</ul>
<p>线程缺点：当进程中的一个线程崩溃时，会导致所属进程的所有线程崩溃</p>
<p>4.4 <strong>线程的实现</strong></p>
<p>用户线程：在用户空间实现的线程。某个用户线程阻塞，进程内所包含的用户线程都不能执行</p>
<p>内核线程：内核中实现的线程，是由操作系统管理的。某个内核线程阻塞并不会影响其他内核线程的运行</p>
<p>轻量级线程LWP：在内核中来支持用户线程</p>
<p>4.5 调度算法</p>
<p>单核CPU系统中常见的调度算法</p>
<ol>
<li><p>先来先服务 FCFS</p>
<p>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行</p>
</li>
<li><p>最短作业优先 SJF</p>
<p>优先选择运行时间最短的进程来运行，有助于提高系统的吞吐量</p>
</li>
<li><p>高响应比优先 HRRN</p>
<p>每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行。</p>
<p>响应比优先级计算公式： 优先权&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间</p>
</li>
<li><p>时间片轮转 RR</p>
<p>每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行</p>
</li>
<li><p>最高优先级 HPF</p>
<p>从就绪队列中选择最高优先级的进程进行运行</p>
</li>
<li><p>多级反馈队列 MFQ</p>
<p>时间片轮转算法+最高优先级算法的综合和发展。</p>
<p>设置多个队列，每个队列不同优先级，从高到低排队，优先级越高，时间片越短。</p>
<p>优点：兼顾长短作业，同时有较好的响应时间</p>
</li>
</ol>
<p>4.6 进程间通信</p>
<p>进程的之间的通信必须通过内核。通信方式有：管道，消息队列，共享内存，信号量，信号，Socket</p>
<ol>
<li><p>管道</p>
<p>所谓管道，就是内核里的一串缓存。管道传输数据是单向的。其通信方式效率低，不适合进程间频繁的交换数据，遵循先进先出</p>
</li>
<li><p>消息队列</p>
<p>消息队列是保存在内核中的消息链表。消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</p>
<p>缺点：通信不及时，附件有大小限制。 因此不适合比较大数据的传输</p>
</li>
<li><p>共享（物理（内存</p>
<p>拿出一块虚拟地址空间映射到相同的物理内存中</p>
<p>缺点：当多个进程同时修改同一个共享内存时，容易冲突</p>
</li>
<li><p>信号量</p>
<p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</p>
<p>控制信号量的方式有两种原子操作</p>
<p>P操作：将信号量减去1，相减后若信号量&lt;0则表明资源被占用，进程需阻塞等待；若相减后信号量&gt;0则表明还有资源可以使用，进程继续执行</p>
<p>V操作：将信号量加上1，相加后若信号量&lt;0则表明当前有阻塞中的进程，于是会将该进程唤醒运行；若信号量&gt;0则表明当前没有阻塞中的进程</p>
<p>P操作用于进入共享资源前，V操作用于离开共享资源后，这两个操作必须成对出现</p>
<p><strong>信号量初始化为0，代表的是同步信号量。信号量初始化为1，代表互斥信号量</strong></p>
</li>
<li><p>信号</p>
<p>对于异常情况下的工作模式，需要用信号的方式来通知进程。信号是进程间通信机制中唯一的异步通信机制</p>
<p>有以下几种用户进程对信号的处理方式</p>
<ol>
<li>执行默认操作。 2. 捕捉信号。可以为信号定义一个信号处理函数，当信号发生时，执行相应的信号处理函数 3. 忽略信号</li>
</ol>
</li>
<li><p>Socket</p>
<p>用于跨网络与不同主机上的进程之间通信</p>
<p>创建socket类型的不同，对应不同的通信方式（有实现TCP字节流通信，UDP数据报通信，本地进程间通信）</p>
<p>在TCP字节流的整个通信过程中会有两个socket，一个是监听socket，另一个是已完成连接socket</p>
<p>TCP通信的服务端的socket需要绑定IP地址及端口，UDP通信的两端都需要绑定IP地址和端口。本地socket进程通信不需要绑定IP地址和端口，而是绑定一个本地文件。</p>
</li>
</ol>
<p>4.7 多线程同步</p>
<p>竞争与协作</p>
<ol>
<li><p><strong>互斥</strong></p>
<p>在多线程相互竞争操作共享变量时，由于时间片结束或其余原因导致执行过程中进程上下文切换。这段互相竞争操作共享变量的代码称为“<strong>临界区</strong>”。它是访问共享资源的代码片段，一定不能给多线程同时执行。因此引入互斥的概念。</p>
<p>互斥：保证一个线程在临界区执行时，其他线程应被阻止进入临界区。 互斥同样可以应用于多进程竞争共享资源的时候</p>
</li>
<li><p><strong>同步</strong></p>
<p>并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种<strong>相互制约的等待与互通信息</strong>称为进程&#x2F;线程同步</p>
</li>
<li><p><strong>互斥与同步的实现和使用</strong></p>
<p>锁：加锁、解锁操作           信号量：P、V操作               信号量的功能比锁更强一点</p>
<p>3.1 <strong>锁</strong></p>
<p>任何想进入临界区的线程，必须先执行加锁操作。在完成对临界资源的访问后在执行解锁操作，释放临界资源</p>
<p>两种简单锁：1. 忙等待锁（自旋锁）2. 无等待锁：当没获取到锁的时候，就把当前线程放入锁的等待队列，将CPU让给其他线程</p>
<p>3.2 <strong>信号量</strong></p>
<p>通常信号量表示资源的数量</p>
<p>实现同步&#x2F;互斥就是用PV操作将代码块包起来，区别是信号量的初值不一样</p>
<p>3.3<strong>生产者-消费者问题</strong></p>
<p>生产者在生成数据后，放在一个缓冲区中</p>
<p>消费者从缓冲区取出数据处理</p>
<p>任何时刻，只能由一个生产者或消费者可以访问缓冲区。可以看出，操作缓冲区是临界代码，需要互斥。</p>
<p>缓冲区空的时候，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步。</p>
<p>3.4 <strong>死锁</strong></p>
<p>两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直互相等待，无法继续运行，这就是死锁</p>
<p>死锁必须同时满足以下四个条件才会发生：</p>
<p><strong>互斥条件</strong>：多个线程不能同时使用同一个资源</p>
<p><strong>持有并等待条件</strong>：线程A需要同时拥有多个资源才能运行时，持有资源1的并等待剩余资源时，并不释放自己以及持有的资源</p>
<p><strong>不可剥夺条件</strong>：当线程持有资源时，在自己使用完之前不能被其他线程获取</p>
<p><strong>环路等待条件</strong>：两个线程获取资源的顺序构成了环形链（例如线程A持有资源1并请求资源2，线程B持有资源2并请求资源1，这就形成了资源请求等待的环形图）</p>
<p>3.5避免死锁问题的发生</p>
<p>避免死锁问题只需要破坏其中一个条件即可，最常见且可行的是：<strong>使用资源有序分配法</strong>，来破坏环路等待条件</p>
<p>资源有序分配法：对线程获取资源的顺序保持一直</p>
</li>
</ol>
<p>几种常见的锁</p>
<ol>
<li><p><strong>互斥锁与自旋锁</strong></p>
<p>它们是许多高级锁的“地基”</p>
<p>互斥锁加锁失败后，线程会释放CPU，给其他线程（<strong>线程切换</strong>）</p>
<p>自旋锁加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁</p>
<p>注：<strong>忙等待</strong>是一种同步机制，其中一个进程或线程<strong>重复检查某个条件</strong>是否满足以便继续执行，而<strong>不是进入休眠或阻塞状态</strong>。这个条件通常与某种资源或锁的可用性有关。忙等待常常与自旋锁相关联，因为自旋锁就是通过忙等待来检查锁的状态。（即反复自检）</p>
<p><strong>互斥锁</strong>是一种<strong>独占锁</strong>，线程A获取互斥锁后，其余线程无法再获取该互斥锁，因此其余线程加锁的代码会被阻塞。在线程A释放互斥锁之后，将锁交还给内核，内核通过唤醒其余线程，继续执行代码。</p>
<p>因此可以知道，互斥锁加锁失败而阻塞的现象，是由<strong>操作系统内核</strong>实现的。互斥锁简化了使用锁的难度，但是增<strong>加了两次线程上下文切换的性能开销成本</strong>（通过内核对其余线程设置为睡眠状态，把CPU切换给其他线程。互斥锁被释放时，内核对睡眠线程进行唤醒，在合适的视角把CPU切换给该线程）。</p>
<p><strong>自旋锁</strong>用于确定被锁住的<strong>代码执行时间很短</strong>，否则使用互斥锁。</p>
<p>自旋锁加锁过程：</p>
<p>第一步查看锁的状态，如果锁是空闲的，则执行第二步</p>
<p>第二步将锁设置为当前线程持有</p>
<p>在单核CPU上，<strong>需要抢占式的调度器</strong>（即不断通过时钟中断一个线程，运行其他线程）。否则自旋锁在单CPU上无法使用，因为<strong>一个自旋的线程永远不会放弃CPU</strong></p>
</li>
<li><p><strong>读写锁</strong>：读和写优先级区分</p>
<p>读写锁适用于能明确区分读操作和写操作的场景</p>
<p>写锁未被线程持有时，多个线程能够并发的持有读锁。 当写锁被某线程持有后，读线程获取读锁的操作会被阻塞，其余写线程获取写锁的操作也会被阻塞</p>
<p>因此写锁是独占锁，读锁是共享锁。</p>
<p>读写锁应用在<strong>读多写少</strong>的场景更有优势</p>
<p>无论是读优先锁还是写优先锁，都有可能会导致另一方线程饥饿的现象。因此引入<strong>公平读写锁</strong></p>
<p>公平读写锁的简单实现方式：</p>
<p>用队列把获取锁的线程排队，不管是写线程还是读线程都按照<strong>先进先出</strong>的原则加锁即可，这样读线程依然可以并发，也不会出现饥饿</p>
</li>
<li><p><strong>乐观锁与悲观锁</strong></p>
<p>前面提到的互斥锁，自旋锁，读写锁都属于悲观锁</p>
<p>悲观锁：多线程同时修改共享资源的概率比较高，很容易出现冲突，所以访问共享资源前需要上锁</p>
<p>乐观锁：先修改完共享资源，再验证这段时间是否发生冲突，如果没有其他线程在修改资源，那么操作完成，否则放弃本次操作。</p>
<p>乐观锁全程并没有加锁，所以也被称为<strong>无锁编程</strong>。乐观锁应用场景：在线文档</p>
<p>乐观锁通过比对版本号进行是否更新提交操作。发生冲突的地方需要重新修改提交。只有在冲突概率非常低，且加锁成本高的场景才考虑使用乐观锁。</p>
</li>
</ol>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><strong>调度算法</strong></h3><ol>
<li><p>进程调度&#x2F;页面置换&#x2F;磁盘调度算法</p>
<p>进程调度算法见4.5小节</p>
<p><strong>内存页面置换</strong>算法：当出现<strong>缺页异常</strong>时，需调入新页面，而内存已满时，选择被置换的物理页面</p>
<p>也就是说，当访问某个页表时，发现内存里没有该页表，CPU从磁盘找到缺页的位置，若物理内存已满，就执行页面置换算法，选择一物理页换出，将该页写回磁盘。</p>
<p>注： 缺页异常指的是CPU访问的页面不在物理内存时，便会产生一个缺页中单，CPU会请求操作系统将所缺页调入到物理内存中。</p>
<p>1） <strong>最佳页面置换算法</strong>：置换在<strong>未来</strong>最长时间不访问的页面</p>
<p>具体实现：需要计算内存中每个逻辑页面的下一次访问时间，然后比较并选择未来最长时间不访问的页面。</p>
<p>该算法无法在实际系统中实现，因为程序访问页面时动态的，无法预知每个页面下一次访问的等待时间。因此该算法时为了<strong>衡量</strong>自己所设计的算法的效率。自己实现的算法效率越接近该算法的效率，说明算法越高效。</p>
<p>2） <strong>先进先出置换算法</strong>：选择在内存<strong>驻留时间很长</strong>的页面进行置换</p>
<p><strong>最近最久未使用的置换算法</strong>（LRU）：选择最长时间没有被访问的页面置换。该算法近似最佳页面置换算法。该算法依据<strong>过去</strong>的使用情况来淘汰页面</p>
<p>缺点：该算法实现的代价很高，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。在每次访问内存时都必须要更新整个链表。性能开销大</p>
<p>3） <strong>时钟页面置换算法</strong>：把所有页面保存在一个类似钟面的环形链表中，一个表针指向最老的页面</p>
<p>在发生缺页中断时，算法首先检查表针指向的页面，若该页面的访问位值为0，则淘汰该页面，将新页面插入这个位置，并将表针前移动一个位置。若访问位为1，则清除访问位（将值变为0），并把表针前移一个位置。重复这个过程，知道找到一个访问位为0的页面。</p>
<p>4） <strong>最不常用算法</strong>：当发生缺页中断时，选择<strong>访问次数最少</strong>的那个页面，将其淘汰。</p>
<p>实现方式：对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器累加1.发生缺页中断时，淘汰计数器最小的页面。</p>
<p><strong>磁盘调度算法</strong></p>
<p>假设有一个请求序列，每个数字代表磁道的位置：[98, 183, 37, 122, 14, 124, 65, 67]，初始磁头当前的位置时在第53磁道。</p>
<p>接下来对以上序列，针对每个磁盘调度算法举例</p>
<p>1）<strong>先来先服务</strong>FCFS</p>
<p>磁盘写入顺序从左往右，先来先服务算法总共移动640个磁道的距离。若大量进程竞争使用磁盘，磁道可能会很分散，性能会变差，因为寻道时间过长</p>
<p>2）<strong>最短寻道时间优先</strong>SSF</p>
<p>根据磁头（53）最近的请求的算法，请求序列会变为[65,67,37,14,98,122,124,183]。磁头移动的总距离为236个磁道。</p>
<p>缺点：该算法可能存在某些请求的饥饿。假设时一个动态的请求，若后续来的请求都小于183，那么第183磁道可能永远无法被响应。产生饥饿的原因是 <strong>磁头在一小块区域来回移动</strong>。</p>
<p>3）<strong>扫描算法</strong></p>
<p>弥补了SSF算法产生饥饿的问题。方法：磁头在<strong>一个方向</strong>上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向。这就是扫描（Scan）算法，也被称为电梯算法</p>
<p>假设扫描调度算法先朝磁道号减少的方向移动，那么新的请求序列：[37,14,0,65,67,98,122,124,183]</p>
<p>4）<strong>循环扫描算法</strong>C-SCAN</p>
<p>只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回途中不处理任何请求</strong>。该算法特点：<strong>磁道只响应一个方向上的请求</strong></p>
<p>新的请求序列[65,67,98,122,124,183,199,0,14,37]其中，磁头碰到最右端的磁道199，立即返回磁盘的最开始处（磁道0），也就是复位磁头。在返回的途中不会响应任何请求（哪怕经过需要处理的请求14，37），直到达到最开始的磁道（0），才继续顺序响应右边的请求。</p>
<p>循环扫描算法对于各个位置磁道响应频率相对比较平均</p>
<p>5）<strong>LOOK与C-LOOK算法</strong></p>
<p>相较于（循环）扫描算法进行了优化。优化点在于将磁头移动到<strong>最远请求位置</strong>后，立即反向移动</p>
<p>针对SCAN算法的优化叫LOOK算法，磁头在每个方向上<strong>仅移动到最远的请求位置</strong>，然后立即反向移动，<strong>反向移动过程中会响应请求</strong></p>
<p>针对C-SCAN算法的优化叫C-LOOK算法，磁头在每个方向上<strong>仅移动到最远的请求位置</strong>，然后立即反向移动，反向移动过程中<strong>不响应请求</strong></p>
</li>
</ol>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><strong>文件系统</strong></h3><p><strong>文件系统的基本组成</strong></p>
<p>Linux文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry）</p>
<p><strong>索引节点</strong>：用来记录文件的元信息，是文件的<strong>唯一标识</strong>。索引节点同样占用磁盘空间</p>
<p><strong>目录项</strong>：记录文件名字，索引节点指针以及其他目录项的层级关联关系。目录项是<strong>由内核维护的一个数据结构，不存在与磁盘，而是缓存在内存</strong></p>
<p>注：个人理解，目录项是一个树结构体，里面有节点名称，以及指针。</p>
<p>补充：<strong>目录</strong>是个文件，持久化存储在磁盘中，<strong>目录项</strong>是一个数据结构，缓存在内存中</p>
<p>因此查询目录的时候，如果频繁从磁盘中读取，性能会差，所以<strong>内核会把已经读过的目录用目录项这个数据结构缓存在内存中</strong>，下次再读到相同的目录时，只需从内存中读即可</p>
<p>问题：文件数据如何存储在磁盘？</p>
<p>磁盘读写的最小单位为<strong>扇区</strong>，大小为512B。文件系统把多个扇区组成一个逻辑块，每次读写的最小单位就是逻辑块（数据块）。Linux中逻辑块大小为4KB，即一次性读写8个扇区</p>
<p><strong>虚拟文件系统</strong></p>
<p>为了对用户提供一个统一的接口，于是操作系统在用户层与文件系统层引入了中间层，这个中间层即为虚拟文件系统（VFS）</p>
<p>文件系统可被分为三类：</p>
<ul>
<li><p>磁盘的文件系统，它是直接把数据存储在磁盘中，比如Ext2&#x2F;3&#x2F;4、XFS等都是这类文件系统</p>
</li>
<li><p>内存的文件系统，这类文件系统的数据占用内存空间，常用到的&#x2F;proc和&#x2F;sys文件系统都属于此类，读写这类文件，实际是读写内核中的相关数据</p>
</li>
<li><p>网络的文件系统，用来访问其他计算机主机数据的文件系统，比如NFS、SMB等等</p>
</li>
</ul>
<p><strong>文件的使用</strong></p>
<p>用户视角里，文件时一个持久化的数据结构；操作系统视角是如何<strong>把文件数据和磁盘块对应起来</strong></p>
<p>用户习惯以字节的方式读写文件，操作系统则是以<strong>数据块</strong>读写文件</p>
<p><strong>读文件和写文件的过程</strong></p>
<ul>
<li><p>当用户进程从文件读取1个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块所对应的用户进程所需的数据部分</p>
</li>
<li><p>当用户进程把1个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，如何修改数据块中对应的部分，最后再把数据块写回磁盘。</p>
</li>
</ul>
<p>文件系统的基本操作单位是数据块</p>
<p><strong>文件的存储</strong></p>
<ol>
<li><p>连续空间存放方式</p>
<p>文件存放在磁盘连续的物理空间中，读写效率很高，一次磁盘寻道即可读出整个文件。</p>
<p>但是这种存放方式需要<strong>提前</strong>知道一个文件的大小，这样文件系统才能根据文件的大小在磁盘上找到一块连续的空间分配给文件</p>
<p>因此文件头里需要指定<strong>起始块的位置和长度</strong>    而缺点是有<strong>磁盘空间碎片和文件长度不易扩展</strong></p>
</li>
<li><p>非连续空间存放方式</p>
<p>链表方式：离散，不用连续的。可以<strong>消除磁盘碎片</strong>，提高了磁盘空间的利用率，文件长度可以动态扩展。具体来说有<strong>隐式链表</strong>和<strong>显式链表</strong>两种形式</p>
<ul>
<li>隐式链表实现方式是文件头要包含<strong>第一块</strong>和<strong>最后一块</strong>的位置，并且每个数据块里留出一个指针空间，用于存放下一个数据块的位置。 缺点是<strong>无法直接访问数据块</strong>，只能通过指针顺序访问，且数据块<strong>指针会占用一定存储空间</strong>。<strong>稳定性差</strong>，因为系统在运行过程中，可能会由于软硬件错误导致指针丢失或损坏，从而导致文件数据丢失</li>
<li>显示链表实现方式是在<strong>内存</strong>中维护一个叫<strong>文件分配表</strong>（FAT）的表格。文件结束的标记是，最后一个指针指向的表格里的数据以一个不属于有效磁盘编号的特殊标记（如-1）。 优点是因为是在内存中查找，因此<strong>提高了检索速度</strong>，<strong>减少了磁盘访问次数</strong>。缺点是<strong>不适用于大磁盘</strong>，因为整个文件分配表是存在内存中的。</li>
</ul>
</li>
<li><p>通过索引存放</p>
<p>为每个文件创建一个<strong>索引数据块</strong>，里面存放的是<strong>指向文件数据块的指针列表</strong>。另外文件头（Inode）需要<strong>包含指向索引数据块的指针</strong></p>
<p>索引的方式优点</p>
<ul>
<li><p>文件的创建，增大，缩小很方便</p>
</li>
<li><p>不会有碎片问题</p>
</li>
<li><p>支持顺序读写和随机读写</p>
</li>
</ul>
<p>索引的缺点是存储索引带来<strong>内存开销</strong></p>
</li>
<li><p>链式索引块（链表+索引）</p>
<p>在索引数据块留出一个存放下一个索引数据块的指针。缺点是如果指针坏了，会导致数据无法读取</p>
</li>
<li><p>多级索引块（索引+索引）</p>
<p>通过一个索引块来存放多个索引数据块</p>
</li>
<li><p>Unix文件的实现方式</p>
<p>集齐顺序分配，链式分配，索引分配的优点：<strong>顺序存取速度快，但文件是定长时</strong>可以根据文件起始地址及记录长度进行<strong>随机访问；无外部碎片，提高了外存空间的利用率，动态增长较方便</strong>；可以<strong>随机访问，易于文件的增删</strong></p>
<p>Unix文件会根据文件的大小，存放的方式有所变化。存放文件所需的数据块小于10块，则直接查找；超过10块，则采用一级简洁索引方式；若前两种都不够存放大文件，则采用二级间接索引方式；若二级间接索引也不够，则采用三级间接索引方式。</p>
<p>因此头文件需要包含13个指针：</p>
<ul>
<li><p>10个直接指向数据块的指针；</p>
</li>
<li><p>第11个指向索引块的指针</p>
</li>
<li><p>第12个指向二级索引块的指针</p>
</li>
<li><p>第13个指向三级索引块的指针</p>
</li>
</ul>
</li>
</ol>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>   <strong>空闲表法</strong></p>
<p>   为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数。注意，这个方式是连续分配的。</p>
<p>   该方法仅适用于当前只有少量的空闲区以及建立连续文件。原因是因为如果存储空间中有着大量的小的空闲区时，空闲表会变得很大，查询效率会很低。</p>
<p>   <strong>空闲链表法</strong></p>
<p>   每一个空闲块里有一个指针指向下一个空闲块。创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当收回空间时，把这些空闲块依次接到链头上。</p>
<p>   主要实现方法就是在主存中保存指针，指向第一个空闲块。缺点时<strong>不能随机访问，工作效率低，指针也占用一定的存储空间。</strong></p>
<p>   空闲表法和空闲链表法都<strong>不适用于大型文件系统</strong>，因为会使空闲（链）表太大</p>
<p>   <strong>位图法</strong></p>
<p>   位图时利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。</p>
<p>   值为0时表示对应的盘块空闲，值为1时表示对应的盘块已分配。</p>
<p>   Linux文件系统就是用位图的方式管理空闲空间，还用于文件头（inode）空闲块的管理</p>
<p>   <strong>文件系统的结构</strong></p>
<p>   文件系统由大量块组组成，在硬盘上相继分布。最前面的第一个块是引导块，系统启动时用于启用引导，紧跟其后的就是一个个连续的块组，块组内容如下：</p>
<ul>
<li><p>超级块，<strong>包含的是文件系统的重要信息</strong>，如inode总个数、块总个数、每个块组的inode个数、每个块组的块个数等等</p>
</li>
<li><p>块组描述符表，包含<strong>文件系统中各个块组的状态</strong>，比如块组中空闲块和inode的数目等，每个块组都包含了文件系统中<strong>所有块组的组描述符信息</strong></p>
</li>
<li><p>数据位图和inode位图，用于表示对应的数据块或inode是空闲的，还是被使用中</p>
</li>
<li><p>inode（文件头）列表，包含了块组中所有的inode，inode用于保存文件系统中与各个文件和目录相关的所有元数据</p>
</li>
<li><p>数据块，包含文件的有用数据</p>
</li>
</ul>
<p>   以上块合并起来则是一个块组</p>
<p>   每个块组里有许多重复信息，如超级块和块组描述符表，这两个都是全局信息，非常重要。这么做有两个原因：</p>
<ul>
<li>若系统崩溃破快乐超级块或快组描述符表，文件系统结构和内容的所有信息会丢失。若有冗余的副本，则有可能恢复</li>
<li>通过使文件和管理数据尽可能接近，减少磁头寻道和旋转，提高文件系统性能</li>
</ul>
<p>   <strong>目录的存储</strong></p>
<p>   目录实际上也是一个文件。普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</p>
<p>   保存目录的格式是<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来。便于查找，插入和删除</p>
<p>   <strong>软链接和硬链接</strong></p>
<p>   硬链接是多个目录项中的<strong>索引节点</strong>指向一个文件，也就是指向同一个inode，但是inode不可能跨越文件系统，也即<strong>硬链接不可用于跨文件系统的</strong>。<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p>   软链接相当于<strong>重新创建一个文件</strong>，这个文件有独立的inode，但这个文件的内容是另一个文件的路径，所以访问软链接实际是访问到另一个文件。也就是说<strong>软链接是可以跨文件系统</strong>的，甚至目标文件被删除，链接文件还是在的，只不过指向的文件找不到了.</p>
<p>   <strong>文件I&#x2F;O</strong></p>
<p>   根据<strong>是否利用标准库缓冲</strong>，可以把文件I&#x2F;O分为缓冲I&#x2F;O和非缓冲I&#x2F;O</p>
<ul>
<li><p>缓冲I&#x2F;O利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件</p>
</li>
<li><p>非缓冲I&#x2F;O是直接通过系统调用访问文件，不经过标准库缓存</p>
</li>
</ul>
<p>   根据<strong>是否利用操作系统缓存</strong>划分<strong>直接与非直接I&#x2F;O</strong></p>
<ul>
<li><p><strong>直接I&#x2F;O</strong>不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘</p>
</li>
<li><p><strong>非直接I&#x2F;O</strong>，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定扫描时候写入数据到磁盘。</p>
</li>
</ul>
<p>   <strong>阻塞与非阻塞I&#x2F;O vs. 同步与异步I&#x2F;O</strong></p>
<ul>
<li><p>阻塞I&#x2F;O：当用户程序执行read，线程会被阻塞，一直等待内核数据准备好，并把数据从内核缓冲区拷贝到应用程序缓冲区之后，才会返回read。 注： 阻塞等待的是 <strong>内核数据准备</strong> 和 <strong>数据从内核态拷贝到用户态</strong> 这两个过程</p>
</li>
<li><p>非阻塞I&#x2F;O：read请求在数据<strong>未准备好的情况下立即返回</strong>，可以继续往下执行，此时应用程序会不断<strong>轮询内核</strong>，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read调用获得结果。在这个情况下，read调用会被执行很多次，最后一次read调用(即数据准备好，进入第二阶段），获取数据的过程是一个<strong>同步</strong>的过程，是需要等待的过程。这里的同步指的是<strong>数据拷贝到应用程序缓冲区的过程</strong></p>
</li>
<li><p>由于不断轮询非常占用cpu，应用程序无法继续执行，因此用<strong>I&#x2F;O多路复用</strong>的方法替代。</p>
<p>以上三种的I&#x2F;O方法都是<strong>同步调用</strong>，因为在read调用时，内核将数据从内核缓存空间拷贝到应用程序缓存缓存空间的时候都需要进行等待。若内核拷贝效率不高，等待时间会久</p>
</li>
<li><p>异步I&#x2F;O则是应用程序不需要等待I&#x2F;O操作完，可以立即继续执行其他任务。在I&#x2F;O操作结束之后，会通过某种机制（回调函数，信号等）通知应用程序&#x2F;进程</p>
</li>
</ul>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a><strong>设备管理</strong></h3><p>   I&#x2F;O设备分为两大类：<strong>块设备和字符设备</strong></p>
<p>   <strong>块设备</strong>，把数据存储在固定大小的块中，每个块有自己的地址，硬盘，USB是常见的块设备</p>
<p>   <strong>字符设备</strong>，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备</p>
<p>   CPU通过两种方法与设备的控制寄存器和数据缓冲区进行通讯</p>
<p>   <strong>端口I&#x2F;O</strong>，每个控制寄存器被分配一个I&#x2F;O端口，可以通过特殊的汇编指令操作这些寄存器，例如in&#x2F;out类似的指令</p>
<p>   <strong>内存映射I&#x2F;O</strong>，将所有控制寄存器映射道内存空间中，这样就可以像读写内存一样读写数据缓冲区</p>
<p>   <strong>I&#x2F;O控制方式</strong></p>
<p>   <strong>轮询等待方法</strong>：让CPU一直查寄存器的状态，直到状态被标记完成。这个方法会占用CPU的全部时间，非常不好</p>
<p>   <strong>中断</strong>：<strong>通知操作系统</strong>数据已经准备好了。设备会有一个硬件的中断控制器。当设备完成任务后则触发中断道中断控制器，中断控制器通知CPU进行接收。</p>
<p>   中断被分为两种，软中断和硬中断。软中断是指软件调用指令进行触发。硬中断是硬件通过中断控制器进行中断。</p>
<p>   中断的缺点是：对于频繁读写数据的磁盘不友好，CPU会经常被打断，浪费时间</p>
<p>   解决方法：使用DMA（Direct Memory Access）功能。DMA允许设备<strong>直接与内存进行数据交换</strong>，而<strong>不需要CPU的持续参与</strong>。实现DMA功能需要有DMA控制器硬件的支持。</p>
<p>   DMA简单理解：在进行I&#x2F;O设备和内存的数据传输的时候，数据搬运的工作全部交给DMA控制器，而CPU不再参与任何与数据搬运相关的事情，这样CPU就可以处理别的事情</p>
<p>   DMA工作方式</p>
<ul>
<li><p>CPU需要对DMA控制器下发指令，例如要获取多少数据，读完的数据放入内存的某个地方</p>
</li>
<li><p>DMA控制器向磁盘控制器发出指令，通知它从磁盘中读取对应数据到磁盘内部的缓冲区，磁盘控制器将其缓冲区内部的数据传输道内存中</p>
</li>
<li><p>在磁盘控制器顺利将数据传入内存之后，磁盘控制器在总线上发出一个确认成功的信号到DMA控制器</p>
</li>
<li><p>DMA控制器收到信号后，发出中断通知给CPU，CPU就可以从内存里读取数据</p>
</li>
</ul>
<p>   <strong>设备驱动程序提供统一的接口给操作系统</strong></p>
<p>   <strong>通用块层</strong>的目的是为了减少不同块设备的差异带来的影响，Linux通过一个统一的通用块层来管理不同的块设备</p>
<p>   通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，主要提供两个功能：</p>
<ul>
<li>向上为文件系统和应用程序<strong>提供访问块设备的标准接口</strong>，向下<strong>把各种不同的磁盘设备抽象为统一的块设备</strong>，并在内核层面提<strong>供一个框架来管理这些设备的驱动程序</strong></li>
<li>块通用层还会给文件系统和应用程序发来的I&#x2F;O请求排队，接着会对队列重新排序、请求合并等方式，也就是<strong>提供I&#x2F;O调度</strong>，目的是<strong>为了提高磁盘读写的效率</strong></li>
</ul>
<p>   Linux内存支持的5中I&#x2F;O调度算法：</p>
<ul>
<li><p>没有调度算法：常用于虚拟机I&#x2F;O中，此时磁盘I&#x2F;O调度算法由物理机系统负责</p>
</li>
<li><p>先入先出调度算法：维护一个队列，先入先出</p>
</li>
<li><p>完全公平调度算法：为每个进程维护一个I&#x2F;O调度队列，按照时间片来均匀分布每个进程的I&#x2F;O请求</p>
</li>
<li><p>优先级调度算法：优先级高的I&#x2F;O请求先发生，适用于大量进程的系统</p>
</li>
<li><p>最终期限调度算法：分别为读、写请求创建<strong>不同</strong>的I&#x2F;O队列，提高机械磁盘的吞吐量，确保达到最终期限的请求被优先处理，适用于在I&#x2F;O压力比较大的场景，例如数据库等</p>
</li>
</ul>
<p>   <strong>存储系统I&#x2F;O软件分层</strong></p>
<p>   Linux存储系统的I&#x2F;O由上到下可以分为三个层次：文件系统层，通用块层，设备层</p>
<ul>
<li><p>文件系统层：包括虚拟文件系统和其他文件系统的具体实现，向上为应用程序提供统一的标准文件访问接口，向下会通过同一块层来存储和管理磁盘数据</p>
</li>
<li><p>通用块层：包括块设备的I&#x2F;O队列和I&#x2F;O调度器，他会对文件系统的I&#x2F;O请求进行排队，再通过I&#x2F;O调度器选择一个I&#x2F;O发个下一层的设备层</p>
</li>
<li><p>设备层：包括硬件设备、设备控制器和驱动程序，负责最终物理设备的I&#x2F;O操作。</p>
</li>
</ul>
   <img src="D:\Typora\pics\Linux存储系统.jpg" style="zoom:30%;" />

<p>   Linux通过提供<strong>页缓存、索引节点缓存、目录项缓存</strong>等多种缓存机制提高文件访问效率，减少对块设备的直接调用</p>
<p>   使用<strong>缓冲区</strong>提高块设备的访问效率，用于缓存块设备的数据</p>
<p>   <strong>总结</strong>：当键盘输入一个字符时会发生什么？</p>
<p>   描述一下连接状况：CPU的内存接口和系统总线直接通信，系统总线接入一个I&#x2F;O桥接器，I&#x2F;O桥接器通过内存总线与内存连接，使得CPU可以和内存进行通信。I&#x2F;O桥接器再连接上I&#x2F;O总线，I&#x2F;O总线上连接多个I&#x2F;O设备（如键盘，显示器）。</p>
<p>   当用户输入某个键盘字符后，键盘控制器会产生扫描码数据，并将其缓冲到键盘控制器的寄存器中，接着键盘控制器通过I&#x2F;O总线与CPU进行通信，发送中断请求。CPU收到中断请求后，操作系统保存被中断进程的CPU上下文，调用键盘的中断处理程序。</p>
<p>   键盘中断处理程序是在键盘驱动程序初始化时注册的，里面有一个<strong>键盘中断处理函数</strong>，该函数的功能时<strong>从键盘控制器里的寄存器中的缓冲区读取扫描码</strong>，找出对应的字符，翻译成ASCII码。之后<strong>将ASCII码放到读缓冲区队列</strong>，显示设备的驱动程序会<strong>定时</strong>从读缓冲区<strong>读取数据放到写缓冲区队列</strong>，最后把写缓冲区队列里的数据依次写入显示设备的控制器中的寄存器里的数据缓冲区，最后进行显示。显示完成后恢复被中断进程的上下文</p>
<h3 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h3><p>   <strong>8.1 Linux是如何收发网络包的</strong></p>
<p>   OSI七层网络模型</p>
<ul>
<li>应用层：负责给应用程序提供统一接口</li>
<li>表示层：负责把数据转换成兼容另一个系统能识别的格式</li>
<li>会话层：负责建立、管理和终止表示层实体之间的通信会话</li>
<li>传输层：负责端到端的数据传输</li>
<li>网络层：负责数据的路由、转发、分片</li>
<li>数据链路层：负责数据的封帧和差错监测，以及MAC寻址</li>
<li>物理层：负责在物理网络中传输数据帧</li>
</ul>
<p>   这个网络模型过于复杂，只是理论上的分层，并不实用</p>
<p>   比较常见且实用的是<strong>TCP&#x2F;IP四层网络模型</strong></p>
<ul>
<li>应用层：负责向用户提供一组应用程序，例如HTTP，DNS，FTP等</li>
<li>传输层：负责端到端的通信，如TCP，UDP</li>
<li>网络层：负责网络包的封装，分片，转发，路由，如IP，ICMP</li>
<li>网络接口层：负责网络包在物理层的传输，如网络包的封帧，MAC寻址，差错检测，以及通过网卡传输网络帧等</li>
</ul>
<p>   <strong>Linux网络协议栈</strong></p>
<p>   TCP&#x2F;IP网络协议各层做的事：</p>
<p>   最原始的应用数据在应用层产生，向下进入到传输层中会在应用数据前添加TCP头，再进入到网络层时添加IP头，进入到网络接口层时，在头尾进行封帧。</p>
<p>   物理链路并不能传输任意大小的数据包，因此在以太网中规定最<strong>大传输单元MTU为1500字节。</strong></p>
<p>   当网络包超过MTU的大小时，会在网络层进行分片。</p>
<p>   Linux网络协议栈的具体实现：</p>
<ul>
<li>应用程序通过系统调用与<strong>Socket层</strong>进行数据交互</li>
<li>Socket层下方就是传输层、网络层和网络接口层</li>
<li>最下方则是物理设备及其驱动程序，即网卡驱动程序与硬件网卡设备</li>
</ul>
<p>   Linux接受网络包的流程</p>
<p>   网卡可以通过触发中断的方式来告诉操作系统收到网络包，但这样的弊端就是CPU频繁中断会影响效率。</p>
<p>   Linux内核在2.6版本引入了<strong>NAPI机制</strong>来解决频繁中断带来的性能开销。它<strong>混合了中断和轮询的方式接收网络包</strong>，核心概念是：<strong>不采用中断的方式读取数据</strong>，而是<strong>采用软中断唤醒数据接收的服务程序</strong>，然后poll的方法来<strong>轮询数据</strong></p>
<p>   <strong>8.2 零拷贝</strong></p>
<p>   以前的I&#x2F;O文件传输的开销很大，一次读写需要切换4次用户态和内核态的上下文切换（因为有两个系统调用，read和write），以及4次的数据拷贝，其中2次是DMA拷贝，另外2次是CPU拷贝。为了提高文件传输的性能，需要<strong>减少用户态与内核态的上下文切换次数和内存拷贝次数</strong>。</p>
<p>   减少用户态和内核态的上下文切换次数的方法是<strong>减少系统调用</strong>，减少内存拷贝次数的方法是<strong>去掉用户的缓冲区</strong></p>
<p>   <strong>零拷贝技术</strong>的实现方式：</p>
<ul>
<li><p>mmap+write</p>
<p>用mmap()替换read()</p>
<p>mmap()系统调用函数会直接把内核缓冲区的里的数据<strong>映射</strong>到用户空间，这样操作系统内核与用户空间就不用进行任何数据拷贝操作。也就是绕过了用户缓冲区，<strong>减少了一次内存拷贝次数</strong></p>
</li>
<li><p>sendfile</p>
<p>通过sendfile()函数替代了read()和write()两个系统调用函数，也就是减少了一次系统调用，共减少2次上下文切换的开销。并且该系统调用直接把内核缓冲区里的数据拷贝到socket缓冲区，不再拷贝到用户态，这样一共只有2次上下文切换，和3次数据拷贝</p>
<p>在Linux内核2.4版本之后，<strong>对于网卡支持SG-DMA技术</strong>的情况下（注：SG是scatter-gather的缩写），sendfile()的系统调用过程发生变化：</p>
<p>第一步，通过DMA将磁盘上的数据拷贝到内核缓冲区</p>
<p>第二步，缓冲区描述符和数据长度传到socket缓冲区，这样网卡的SG-DMA控制器可以<strong>直接将内核缓存中的数据拷贝到网卡的缓冲区里</strong>，这个过程不需要将数据从操作系统内核缓冲区拷贝到socket缓冲区，也即减少了一次数据拷贝</p>
<p>而这就是所谓的<strong>零拷贝技术</strong>（支持SG-DMA的网卡且Linux内核版本在2.1以上）。</p>
<p>原因是：没有在内存层面去拷贝数据，换句话说没有通过CPU来搬运数据，所有数据都是通过DMA来进行传输的</p>
<p>零拷贝技术<strong>只需要2次上下文切换和数据拷贝次数</strong>，即可完成文件传输，而2次的数据拷贝过程都不要CPU进行参与，均由DMA来搬运。零拷贝技术可以把文件传输性能提高至少一倍以上</p>
<p>使用零拷贝技术的项目：Kafka, Nginx</p>
</li>
</ul>
<p>   <strong>磁盘高速缓存PageCache</strong></p>
<p>   ​	读写磁盘的速度远慢于读写内存。用<strong>PageCache来缓存最近被访问的数据</strong>，空间不足时淘汰最久未被访问的缓存</p>
<p>   ​	PageCache两个优点：<strong>缓存最近被访问数据，预读功能</strong></p>
<p>   ​	缺点：在传输大文件（GB级别文件）时，PageCache会不起作用，那就白白浪费DMA多做的一次数据拷贝，造成性能的降低，即	使使用了PageCache的零拷贝也会损失性能</p>
<p>   ​	因此<strong>针对大文件的传输，不应该使用PageCache，即不应该使用零拷贝技术</strong>，因为PageCache可能会被大文件占据，导致<strong>热点</strong>小	文件无法利用PageCache，反而造成性能的降低。尤其在高并发的环境下，会带来严重的性能问题。</p>
<p>   <strong>大文件传输</strong></p>
<p>   在高并发的场景下，针对大文件的传输方式，应该使用异步I&#x2F;O+直接I&#x2F;O的方式来替代零拷贝技术</p>
<p>   举一个普通异步I&#x2F;O文件传输的例子</p>
<p>   用户进程发起I&#x2F;O请求，调用异步read函数，内核收到该函数之后，<strong>不等待数据准备完成直接返回</strong>，让CPU继续执行。内核向磁盘发起I&#x2F;O请求，磁盘收到后对内核发起I&#x2F;O中断，<strong>内核将数据从磁盘控制器缓冲区拷贝到用户缓冲区</strong>，拷贝完成后内核向CPU进行通知。</p>
<p>   可以发现，异步I&#x2F;O并没有涉及到PageCache，所以使用异步I&#x2F;O意味着绕开了PageCache</p>
<p>   <strong>8.3 I&#x2F;O多路复用：select&#x2F;poll&#x2F;epoll</strong></p>
<p>   最基本的socket模型</p>
<p>   介绍tcp的socket编程</p>
<p>   服务端调用socket()函数，创建网络协议（可以指定网络层使用的是IPv4还是IPv6，传输层用的是TCP还是UDP），接着调用bind()函数，给这个socket绑定一个<strong>IP地址和端口</strong>，绑定的目的是：</p>
<ul>
<li>绑定端口的目的：当内核而受到TCP报文，通过TCP头里的端口号来找到应用程序，然后将数据传递给用户</li>
<li>绑定IP地址的目的：一台机器是可以有多个网卡，每个网卡都有对应的IP地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给用户</li>
</ul>
<p>   绑定完IP地址和端口后，调用listen()函数进行监听，此时对应TCP状态图中的listen，如果我们要判断服务器中的一个网络程序有没有启动，通过netstat命令查看对应端口号是否有被监听</p>
<p>   服务端进入监听状态后，通过调用accept()函数来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来</p>
<p>   客户端在创建好socke后，调用connect()函数发起连接，该函数的参数要指明服务端的IP地址和端口号，然后进行TCP三次握手</p>
<p>   在TCP连接过程中，服务器内核实际上为每个Socket维护了两个队列：</p>
<ul>
<li>还未完全建立连接的队列，即<strong>TCP半连接队列</strong>，这个队列都是没有完成三次握手的连接，此时服务端处于syn_rcvd状态</li>
<li>已经建立连接的队列，即<strong>TCP全连接队列</strong>，这个队列都是完成三次握手的连接，此时服务端处于estabilished状态</li>
</ul>
<p>   当TCP全连接队列不为空时，服务端的accept()函数会从内核中的TCP全连接队列中取出一个已经完成连接的Socket返回给应用程序，后续的数据传输都用这个Socket</p>
<p>   注：监听的Socket和这种用来传数据的Socket是两个</p>
<ul>
<li>一个为<strong>监听Socket</strong></li>
<li>一个为<strong>已连接Socket</strong></li>
</ul>
<p>   连接建立后双方都有可以通过read()和write()函数来读写数据</p>
<p>   <strong>内核里的数据结构</strong></p>
<p>   每个进程里都有一个数据结构 track_struct ，该结构体里有一个<strong>指向文件描述符数组</strong>的成员指针，该数组里列出这个进程打开的所有文件的文件描述符。数组下标是文件描述符，是一个整数类型，数组内容是一个指针，指向内核中所有打开的文件的列表。也就是说，<strong>内核可以通过文件描述符找到对应打开的文件</strong></p>
<p>   每个文件都有一个inode，例如socket文件的inode指向了内核中的socket结构，在socket结构体里有两个队列，发送队列和接收队列，这两个队列里面保存的是一个个struct sk_buff，用链表组织形式串起来</p>
<p>   sk_buff可以表示各个层的数据包，在应用层叫data，tcp层叫segment，ip层叫packet，数据链路层叫frame</p>
<p>   在各层之间传递数据时，通过调整 sk_buff 中的data的指针来进行包装&#x2F;剥离协议首部</p>
<p>   TCP连接是由<strong>四元组</strong>唯一确认的，四元组是：<strong>本机IP，本机端口，对端IP，对端端口</strong></p>
<p>   <strong>最大TCP连接数&#x3D;客户端IP数 × 客户端端口数</strong>  客户端IP数最多为2的32次方，端口数最多为2的16次方</p>
<p>   因此<strong>服务端单机最大TCP连接数约为2的48次方</strong></p>
<p>   <strong>多进程模型</strong></p>
<p>   若服务器要支持多个客户端，比较传统的解决方式是使用多进程模型，也就是为每个客户端分配一个进程来处理请求。</p>
<p>   服务端主进程负责监听客户的连接，完成客户端连接后，accept()函数返回一个已连接socket，这时通过fork()函数创建一个子进程，实际上就是把父进程所有相关的东西<strong>复制</strong>一份，包括文件描述符，内存地址空间，程序计数器，执行的代码等</p>
<p>   这意味着将监听socket和已连接socket进行分离，<strong>子进程只需要关心已连接socket，父进程只需要关心监听socket</strong></p>
<p>   子进程退出时，内核还会保留该进程的一些信息，也是会占用内存的，如果不做好<code>回收</code>工作，则会变成<strong>僵尸进程</strong>，占有系统资源</p>
<p>   两种方式在子进程退出后回收资源，wait()和waitpid()函数</p>
<p>   这个模型不适用客户端数量非常多的场景，因为每产生一个进程，必定会占据一定的系统资源</p>
<p>   <strong>多线程模型</strong></p>
<p>   线程是运行在进程中的一个<em>逻辑流</em>。同进程里的线程可以共享进程的部分资源，这些共享资源在上下文切换时是不需要切换的，只需要切换线程的私有数据、寄存器等不共享数据。因此同一个进程下的线程上下文切换的开销比进程小的多</p>
<p>   但是频繁的创建和销毁线程依旧带来了很大的系统开销，解决方法是用<strong>线程池</strong>。</p>
<p>   <strong>I&#x2F;O多路复用</strong></p>
<p>   只使用一个进程来维护多个Socket。也就是说 多个请求复用一个进程</p>
<p>   select&#x2F;poll&#x2F;epoll内核是提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可</p>
<p>   <strong>select&#x2F;poll</strong></p>
<p>   select实现多路复用的方式是，<strong>将已连接的Socket都放到一个文件描述符集合</strong>，之后调用select函数将文件描述集合<strong>拷贝到内核</strong>，让内核检查是否有网络事件产生，检查的方式是<strong>遍历集合</strong>，当检查到有事件产生后，<strong>将此Socket标记为可读或可写</strong>，接着把整个文件描述符集合<strong>拷贝回用户态</strong>，用户态还需要<strong>再遍历</strong>，找到可读或可写的socket，再进行处理</p>
<p>   select 的主要用途是在单个线程中同时处理多个 I&#x2F;O 操作，从而提高程序的效率。</p>
<p>   因此发生了两次拷贝和两次遍历。</p>
<p>   poll方法和select的区别在于表示文件描述符集合的数据类型不一样，select使用固定长度的BitsMap，所支持的文件描述符的个数是有限的，只能监听1024个。而poll不再使用BitsMap，用动态数组取代，以链表的形式来组织，突破了文件描述符个数限制，但是还会受到系统文件描述符的限制</p>
<p>   poll和select都是使用<strong>线性结构存储</strong>进程关注的Socket集合，<strong>都需要遍历文件描述符集合</strong>来找到可读或可写的Socket，因此**时间复杂度为O(n)**，而且也需要在用户态和内核态之间拷贝文件描述符集合。不适合并发场景</p>
<p>   <strong>epoll</strong></p>
<p>   epoll从两个方面解决select和poll的问题</p>
<ul>
<li>epoll在内核里使用<strong>红黑树</strong>来跟踪进程里<strong>所有待检测的文件描述符</strong>。红黑树增删查的<strong>一般时间复杂度为O(logn)<strong>，通过对红黑树进行操作，主要要</strong>传入一个待检测的socke</strong>t，而不是进行遍历，减少了内核和用户空间的大量拷贝以及内存分配</li>
<li>epoll使用事件驱动机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，某个socket有事件发生时，通过回调函数内核会将其加入到这个就绪时间链表中，用户调用epoll_wait()函数时，只会返回有事件发生的文件描述符的个数</li>
</ul>
<p>   epoll的方式即使socket数量越多，效率也不会大幅度降低。<strong>epoll被称为解决C10K问题的利器</strong></p>
<p>   注：C10K问题是指 10K个客户端（C）同时对服务端进行请求</p>
<p>   <strong>epoll两种事件触发模式</strong></p>
<ul>
<li>边缘触发模式（edge-triggered，ET）：当被监控的Socket描述符上有可读事件发生时，<strong>服务器端只会从epoll_wait中苏醒一次，</strong>即使进程没有调用read函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完。</li>
<li>水平触发模式（level-triggered，LT）：当被监控的Socket描述符上有可读事件发生时，<strong>服务器端不断地从epoll_wait中苏醒，直到内核缓冲区数据被read函数读完才结束</strong>，目的是告诉我们有数据需要读取</li>
</ul>
<p>   简而言之，边缘触发就是只有第一次满足条件时才会触发，之后就不会再传递相同的事件了。</p>
<p>   水平触发的意思是只要满足事件的条件，比如内核中有数据要读，就会一直不断地把这个事件传递给用户。</p>
<p>   使用边缘触发模式，I&#x2F;O事件发生仅通知一次，因此在收到通知后要尽可能地读写数据，<strong>循环从文件描述符读写数据</strong>。若文件描述符阻塞了，进程就会阻塞在读写函数那边。<strong>因此边缘触发模式一般和非阻塞I&#x2F;O搭配使用</strong>，程序会一直执行I&#x2F;O操作，直到系统调用返回错误，错误类型为EAGAIN或EWOULDBLOACK</p>
<p>   多路复用API返回的事件并不一定可读写的</p>
<p>   8.4 <strong>高性能网络模式：Reactor 和 Proactor</strong></p>
<p>   Reactor模式的含义是：来了一个事件，Reactor就有相对应的反应&#x2F;响应。Reactor模式又名Dispatcher模式，<strong>即I&#x2F;O多路复用监听事件，收到事件后，根据事件类型分配（Dispatich）给某个进程&#x2F;线程</strong></p>
<p>   Reactor模式主要由Reactor和处理资源池两个核心部分组成：</p>
<ul>
<li>Reactor负责监听和分发事件，事件类型包含连接事件、读写事件</li>
<li>处理资源池负责处理事件，如read -&gt; 业务逻辑 -&gt; spend</li>
</ul>
<p>   <strong>单Reactor单进程&#x2F;线程</strong></p>
<p>   一般来说，C语言实现的是单Reactor单进程，Java实现的是单Reactor单线程。因为Java程序跑在JVM这个进程上，虚拟机里由许多线程，所写的Java程序只是其中的一个线程</p>
<p>   <strong>具体实现</strong>：该方案里有三个对象：Reactor，Acceptor和Handler。在客户端请求应用程序时，先请求Reactor对象，调用对象内部的select方法（I&#x2F;O多路复用）来监听事件状态，收到后通过dispatch进行分发，如果是建立连接事件，就交给Acceptor对象进行处理（Acceptor对象里有一个accept方法获取连接，并创建一个Handler对象来处理后续的响应事件），如果不是建立连接事件，则直接交给对应的Handler对象来进行响应。Handler对象通过read -&gt; 业务逻辑 -&gt; spend流程来完成整个业务流程</p>
<p>   该方案缺点存在2个缺点：</p>
<ul>
<li>只有一个进程，<strong>无法充分利用多核CPU的性能</strong></li>
<li>Handler对象在处理业务时，整个进程无法处理其他连接事件，<strong>如果业务处理耗时长，会造成响应的延迟</strong></li>
</ul>
<p>   单Reactor单进程&#x2F;线程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong></p>
<p>   采用单Reactor单进程&#x2F;线程的中间件：Redis</p>
<p>   <strong>单Reactor多进程&#x2F;多线程</strong></p>
<p>   和单Reactor单进程&#x2F;线程的区别主要在业务处理这一块：</p>
<ul>
<li><strong>Handler对象不再负责业务处理，只负责数据的接收与发送</strong>，Handler对象通过read读到数据后，将数据发给<strong>子线程里的Processor对象进行业务处理</strong></li>
<li>子线程里的Processor对象对业务处理完成后，将结果发给主线程里的Handler对象，Handler通过send方法将响应结果发给client</li>
</ul>
<p>   单Reactor模式存在的问题：<strong>一个Reactor对象承担所有事件的监听和响应，</strong>且只在主线程中运行，在瞬间高并发的场景时<strong>，容易成为性能瓶颈的地方</strong>。</p>
<p>   <strong>多Reactor多进程&#x2F;多线程</strong></p>
<ul>
<li><p>主线程中的MainReactor对象通过select监控连接建立事件，收到事件后通过Acceptor对象中的accept获取连接，将新的连接分配给某个子线程</p>
</li>
<li><p>子线程中的SubReactor对象将MainReactor对象分配的连接加入select继续进行监听，并创建一个Handler由于处理连接的响应事件</p>
</li>
<li><p>如果有新的事件发生，SubReactor对象会调用当前连接对应的Handler对象来进行响应</p>
</li>
<li><p>Handler对象通过read -&gt; 业务逻辑 -&gt; spend流程来完成整个业务流程</p>
</li>
</ul>
<p>   采用多Reactor多进程&#x2F;多线程方案的应用程序：Netty，Memcache，Nginx</p>
<p>   <strong>Proactor</strong></p>
<p>   Reactor是非阻塞同步网络模式，<strong>感知的是就绪可读写事件</strong>。可以理解为，<strong>来了事件，操作系统通知应用进程，让应用进程来处理</strong></p>
<p>   Proactor是异步网络模式，<strong>感知的是已完成的读写事件</strong>，可以理解为，<strong>来了事件，操作系统来处理，处理完再通知应用程序</strong></p>
<p>   无论是Reactor还是Proactor，都是一种基于事件分发的网络变成模式，区别在于<strong>Reactor模式是基于待完成的I&#x2F;O事件，而Proactor是基于已完成的I&#x2F;O事件</strong></p>
<p>   Proactor工作流程</p>
<ul>
<li>Proactor Initiator负责创建Proactor和Handler对象，并将Proactor和Handler都通过Asynchronous Operation Processor注册到内核</li>
<li>Asynchronous Operation Processor负责处理注册请求，并处理I&#x2F;O操作</li>
<li>Asynchronous Operation Processor完成I&#x2F;O操作后通知Proactor</li>
<li>Proactor根据不同的事件类型回调不同的Handler进行任务处理</li>
<li>Handler完成业务处理</li>
</ul>
<p>   8.5 什么是一致性哈希？</p>
<p>   一般的负载均衡方法是引入一个中间的负载均衡层，将外界请求轮流转发给内部集群。再考虑到每个节点的硬件配置的区别，可以引入权重值。这种方法是<strong>加权轮询算法</strong>。但这个方法无法应对分布式系统，因为在分布式系统中，每个节点存储的数据是不同的。</p>
<p>   一个分布式KV（key-value）缓存系统，某个key应该到哪个或哪些个节点上获得，应该是确定的。因此需要引入能应对分布式系统的负载均衡算法。</p>
<p>   如果单纯使用哈希算法来解决的话，如果节点数量发生变化的时候，必须迁移，这样会改变大部分数据的映射关系。所以需要使用一致性哈希算法，解决了分布式系统在扩容或缩容时发生过多数据迁移的问题</p>
<p>   <strong>一致性哈希算法</strong>是对2^32进行取模运算，因此是一个固定的值，将结果值组成圆环，可以理解成由60个点组成的圆，这个圆环被称为<strong>哈希环</strong></p>
<p>   一致性哈希需要进行两步哈希：</p>
<ul>
<li>对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的IP地址进行哈希</li>
<li>对数据进行存储或访问时，对数据进行哈希</li>
</ul>
<p>   所以，<strong>一致性哈希是指将存储节点和数据都映射到一个首尾相连的哈希环上</strong></p>
<p>   对数据进行哈希映射得到的结果存放在<strong>顺时针方向上的第一个节点</strong>。</p>
<p>   一致性哈希有一个问题，就是数据倾斜，也就是节点分布不均匀，导致大量的数据的寻址只去寻找某一个或某几个节点，没有负载均衡。<strong>引入虚拟节点来解决数据倾斜问题</strong></p>
<p>   虚拟节点具体做法：<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有两层映射关系</strong></p>
<p>   节点数量变多了，节点在哈希环上的分布就相对均匀了，并且当节点发生变化时，会有不同的节点共同分担系统的变化，稳定性更好</p>
<p>   因此，带虚拟节点的一致性哈希算法不仅适合硬件配置不同的节点的场景，而且适合节点规模会动态变化的场景</p>
<h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><p>   9.1 如何<strong>查看网络的性能指标</strong></p>
<p>   通常以4个指标衡量网络性能：</p>
<ul>
<li>带宽，表示链路的最大传输速率，单位是b&#x2F;s（比特&#x2F;秒），带宽越大，其传输能力越强</li>
<li>延时，表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立TCP连接所需要的时间延迟，或一个数据包往返所需的时间延迟</li>
<li>吞吐率，表示单位时间内成功传输的数据量，单位是b&#x2F;s（比特&#x2F;秒）或者B&#x2F;s（字节&#x2F;秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高</li>
<li>PPS，全称是Packet Per Second（包&#x2F;秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能力</li>
</ul>
<p>   除了以上四种基本指标，还有一些其他常用的性能指标：</p>
<ul>
<li>网络的可用性，表示网络能否正常通信</li>
<li>并发连接数，表示TCP连接数量</li>
<li>丢包率，表示所丢失数据包数量占所发送数据组的比率</li>
<li>重传率，表示重传网络包的比例</li>
</ul>
<p>   <strong>查看网络配置</strong></p>
<p>   使用<code>ipconfig</code>或者<code>ip命令</code>来查看网络的配置和状态</p>
<p>   使用<code>netstat</code>或者<code>ss</code>这两个命令来查看socket、网络协议栈、网口以及路由表的信息。</p>
<p>   注：尽量不使用<code>netstat</code>命令，因为它的性能不好，在系统繁忙时，频繁使用<code>netstat</code>命令则会对性能的开销雪上加霜，推荐使用<code>ss</code>命令</p>
<p>   在不同的socket状态，接收队列（Recv-Q）和发送队列(Send-Q)所表示的含义不同</p>
<p>   当socket状态处于<code>Established</code>时：</p>
<ul>
<li>接收队列（Recv-Q）表示socket缓冲区中还没有被应用程序读取的字节数</li>
<li>发送队列(Send-Q)表示socket缓冲区中还没有被远端主机确认的字节数</li>
</ul>
<p>   当socket状态处于<code>Listen</code>时：</p>
<ul>
<li>接收队列（Recv-Q）表示全连接队列的长度</li>
<li>发送队列(Send-Q)表示全连接队列的最大长度</li>
</ul>
<p>   全连接队列指的是服务器与客户端完成TCP三次握手后，还没有被accept()系统调用取走连接的队列</p>
<p>   <strong>查看网络吞吐率和PPS</strong></p>
<p>   使用<code>sar</code>命令查看当前网络的吞吐率和PPS，用法是给<code>sar</code>增加<code>-n</code>参数就可以查看网络的统计信息，例如：</p>
<ul>
<li>sar -n DEV， 显示网口的统计信息</li>
<li>sar -n EDEV，显示关于网络错误的统计数据</li>
<li>sar -n TCP，显示TCP的统计数据</li>
</ul>
<p>   举例，运行 <code>sar -n DEV 1</code> 命令获取网口的统计信息（注：数字1表示的是每隔1秒输出一组数据）</p>
<p>   会出现以下几个关键字：</p>
<ul>
<li><code>rxpck/s</code> 和<code>txpck/s </code>分别是接收和发送的PPS，单位是包&#x2F;秒</li>
<li><code>rxkB/s</code>和<code>txkB/s</code>分别是接受和发送的吞吐率，单位是KB&#x2F;秒</li>
<li><code>rxcmp/s</code>和<code>txcmp/s</code>分别是接收和发送的压缩包数，单位是包&#x2F;秒</li>
</ul>
<p>   对于带宽，使用<code>ethool</code>命令来查询，单位通常是<code>Gb/s</code>或者<code>Mb/s</code></p>
<p>   <strong>连通性和延时性查看</strong></p>
<p>   使用<code>ping</code>命令</p>
<p>   值得注意的是，<code>ping</code>不通服务器并不代表HTTP请求也不通，因为有的服务器的防火墙是禁用ICMP协议的</p>
<p>   9.2 <strong>如何从日志分析PV、UV</strong></p>
<p>   PV：页面访问次数</p>
<p>   UV：访问人数</p>
<p>   第一步先用<code>ls -lh</code>命令来查看日志文件的大小，若日志文件非常大，不建议在线上环境做</p>
<p>   所以要慎用<code>cat</code>命令，该命令是直接把日志文件的所有数据全部读出来。对于大文件，用<code>less</code>命令去读，它是按需加载的</p>
<p>   <code>tail</code>命令是用来查看最新部分的内容，比如说要查看access.log文件倒数5行的内容，命令是<code>tail -n 5 access.log</code></p>
<p>   如果想试试看日志打印内容，使用<code>tail -f</code>命令</p>
<p>   <strong>PV分析</strong></p>
<p>   PV(Page View)， 用户访问一个页面就是一次PV，点击一次页面也是一次PV，PV的数量不代表真实的用户数量，只是点击量。</p>
<p>   如果要查看access.log文件的PV数量，直接使用<code>wc -l</code>命令，<code>wc -l access.log</code></p>
<p>   <strong>PV分组</strong></p>
<p>   可以使用<code>awk</code>命令对文件内的信息进行分组，例如先过滤出访问时间（这个条目在日志的第四列）可以使用</p>
<p>   <code>awk &#39;&#123;print$4&#125;&#39; access.log</code></p>
<p>   输出：<em>17&#x2F;Jan&#x2F;2021:10:07:12</em> 结构的时间，上面的信息包含了时分秒，如果只想显示年月日，用<code>awk</code>的<code>substr</code>函数，从第2个字符截取11个字符  <code>awk &#39;&#123;print substr($4, 2, 11)&#125;&#39; access.log</code> 现在输出为: <em>17&#x2F;Jan&#x2F;2021</em></p>
<p>   接着可以用<code>sort</code>对日期进行排序，使用<code>uniq -c</code>进行统计<code>awk &#39;&#123;print substr($4, 2, 11)&#125;&#39; access.log | sort | uniq -c</code> </p>
<p>   输出： <em>2837 01&#x2F;Jun&#x2F;2021</em> 第一个数字为该日期的日志条目数量，即<strong>当天的PV数量</strong></p>
<p>   注：<strong>使用<code>uniq -c</code>命令前，先要用<code>sort</code>排序</strong>，因为<code>uniq -c</code>命令去重的原理是比较相邻的行，所以先排序，使所有重复行响铃</p>
<p>   <strong>UC分析</strong></p>
<p>   UV(Uniq Visitor)，代表访问人数，比如公众号的阅读量就是以UV统计的，无论单个用户点击多少次，最终只算1次阅读量</p>
<p>   在access.log日志中，用<em>客户端IP地址</em>来<strong>近似</strong>统计UV</p>
<p>   使用<code>awk &#39;&#123;print $1&#125;&#39; access.log | sort | uniq | wc -l</code> 命令，获得输出 <em>2589</em>，即UV的数量</p>
<ul>
<li><code>awk &#39;&#123;print $1&#125;&#39; access.log</code>, 取日志的第1列内容，即客户端IP地址</li>
<li><code>sort</code> 对信息排序</li>
<li><code>uniq</code>去除重复的记录</li>
<li><code>wc -l</code> 查看记录条数</li>
</ul>
<p>   <strong>UV分组</strong></p>
<p>   目标：按天来分组分析每天的UV数量，即 要把<em>日期+IP地址</em>过滤出来，并去重</p>
<p>   命令：<code>awk &#39;&#123;print substr($4, 2, 11) &quot; &quot; $1&#125;&#39; access.log | sort | uniq</code></p>
<p>   分析：</p>
<ul>
<li><code>awk &#39;&#123;print substr($4, 2, 11) &quot; &quot; $1&#125;</code>是将第4列的日期和第1列的客户端IP地址过滤出来，并用空格拼接</li>
<li><code>sort</code>对第一次ack的输出的内容进行排序</li>
<li>用<code>uniq</code>去除重复的记录，即日期+IP相同的行就保留一个</li>
</ul>
<p>   如果需要对当天的UV统计，再拼接<code>awk &#39;&#123;uv[$1]++;next&#125;END&#123;for (ip in uv) print ip, uv[ip]&#125;&#39;</code>命令即可</p>
<p>   即<code>awk &#39;&#123;print substr($4, 2, 11) &quot; &quot; $1&#125;&#39; access.log | sort | uniq | awk &#39;&#123;uv[$1]++;next&#125;END&#123;for (ip in uv) print ip, uv[ip]&#125;&#39;</code></p>
<p>   输出如下 ： <em>18&#x2F;Jan&#x2F;2021 252</em></p>
<p>   解释： awk命令本身是逐行进行处理的，当执行完一行后，用<code>next</code>关键字来告诉awk跳转到下一行，把下一行作为输入</p>
<p>   对每一行的输入，awk会根据第1列字符串进行累加，这样相同日期的ip地址就会累加起来，作为当天的uv数量</p>
<p>   之后的<code>END</code>关键字代表一个触发器，就是当前面的输入全部完成后，才会执行END{}里的语句，END的语句是通过foreach遍历uv中所有的key，打印出按天分组的uv数量</p>
<p>   <strong>终端分析</strong></p>
<p>   nginx的access.log日志最末尾是关于User Agent的信息，就是客户端访问服务端所使用的终端(手机，浏览器等)</p>
<p>   用<code>awk</code>过滤出第12列的内容，进行<code>sort</code>排序，再用<code>uniq -c</code>去重并统计，最后使用<code>sort -rn</code>（r表示逆向排序，n表示按数值排序）对统计结果排序。</p>
<p>   命令<code>awk &#39;&#123;print $12&#125;&#39; access.log | sort | uniq -c | sort -rn</code>  输出： <em>22768 “Debian”</em></p>
<p>   <strong>分析TOP3的请求</strong></p>
<p>   access.log日志中，第7列是客户端请求的路径，用<code>awk</code>过滤出第7列内容，进行<code>sort</code>排序，再用<code>uniq -c</code>去重并统计，然后再使用<code>sort -rn</code>对统计结果排序，最后使用<code>head -n 3</code>分析TOP3的请求</p>
<p>   命令 <code>awk &#39;&#123;print $7&#125;&#39; access.log | sort | uniq -c | sort -rn | head -n 3</code></p>
<p>   输出： </p>
<p>   <em>29249 &#x2F;live&#x2F;001&#x2F;index.m3u8</em></p>
<p>   <em>20556 &#x2F;live&#x2F;002&#x2F;index.m3u8</em></p>
<p>   69 &#x2F;live&#x2F;003&#x2F;index.m3u8*</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="tag"># 学习总结</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="HTTP相关">
      HTTP相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">操作系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">空闲空间管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">设备管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.</span> <span class="nav-text">网络系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">Linux命令</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhan"
      src="https://raw.githubusercontent.com/Vnio0926/hexo-pic/master/img/fd0ae4423b520e2f15f345f0a369e08.jpg?token=BDPWDDEMRKIEUWVPL6ZR23LHJHGYA">
  <p class="site-author-name" itemprop="name">Zhan</p>
  <div class="site-description" itemprop="description">莫欺少年穷 莫欺中年穷 莫欺老年穷 死者为大</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Vnio0926" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Vnio0926" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zhanzhiji0926@outlook.com" title="E-Mail → zhanzhiji0926@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhan</span>
</div>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <br>
    <span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人</span>





        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '11GPD64fulbxgFxOJ6a8xtSB-MdYXbMMI',
      appKey     : 'LlWMKmFqbIbgWGBcpCgQwMzX',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
